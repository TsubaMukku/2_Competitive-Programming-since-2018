//すべての２頂点の間の最短経路の長さを求めるアルゴリズムである

/*
問題例

abc016 C 友達の友達 https://atcoder.jp/contests/abc016/tasks/abc016_3

*/






//使う場面
//(1) ２つの頂点の間の最短経路の長さを求めたいとき
-> すべてのedgeの重みを１に設定することが多い. このばあい, 経路の重み == 経路上のエッジの数となる


//DP配列を用いて実装する
//O(V^3)
//実装が簡単である. 
//このため, 計算量に余裕がある場合, 単一始点最短経路問題でも, ワーシャルフロイドの利用を考えると良い.



//実装のテンプレ 

//(1) distを初期化する
/*
距離を保持する配列 distを準備する long long dist[MAX_V][MAX_V]
辺がない場合もあるため, distの各要素は, inf（非常に大きな値）で初期化しておく
自分自身への距離は0である. dist[i][i] = 0である.
*/

//nは頂点数である
for (int i = 0; i < n; i++) {
  for (int j = 0; j < n; j++){
    dist[i][j] = INF;
    dist[i][i] = 0;
  }
}

//(2) グラフ G = (V, E) および各辺 e ∈ E の長さ length(e) を入力として受け取る。

//mは頂点間のエッジの本数である
for (int i = 0; i < m; i++){
  int a, b;
  cin >> a >> b;
  a--, b--; //0-indexの場合
  G[a][b] = G[b][a] = 1; //costの設定
}


//(3) 
/*
動的計画法を使う
dp[k][i][j]: 0からk-1までの頂点を使い, 頂点iから頂点jまで移動するときの最小コスト、と定義する.
最短経路が, 頂点kを含まない場合, 含む場合の２通りを考える
*/

//経由頂点k
for(int k=0;k<V;k++){

    //スタート頂点i
    for(int i=0;i<V;i++){
    
        //ゴール頂点j
        for(int j=0;j<V;j++)dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);
    }
}


